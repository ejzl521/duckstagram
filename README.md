# Duckstagram
- recoil, react-query를 이용한 반응형 웹사이트 만들기
![6](https://user-images.githubusercontent.com/55455103/173968229-b7aa218b-c560-445c-ab51-0e310668e50a.gif)
![10123](https://user-images.githubusercontent.com/55455103/174459459-0ecd2a9d-2eae-4b48-9d3a-326e82b4ede4.gif)


# 주 라이브러리
### recoil & recoil-persist
- 전역 상태 유지 
- ex) 로그인한 사용자의 token을 저장
### react-query
- 서버 상태 유지
- ex) 서버에 저장되어있는 게시글의 상태를 항상 최신으로 유지
### eslint & prettier
- 프로젝트 내에서 코딩 컨벤션을 동일하게 하기 위해 사용
### axios
- HTTP request & respose
### yup & formik
- form의 상태 관리 및 validation 검사
- ex) 회원가입할 때 비밀번호는 8글자 이상 및 숫자와 특수문자 하나 반드시 포함

# Why recoil?
### 기존 상태관리 라이브러리의 문제점
- 기존에 사용되었던 Redux나 Mobx가 성능 자체에 문제가 있던 것이 아니라 오히려 Flux 패턴을 기반으로 안정적이지만 여러가지 문제가 존재했다
- React 전용 라이브러리가 아니기에 React가 볼 때 Store가 외부의 어떤 것이며 동시성 모드를 구현하기에 호환성이 떨어진다
- 복잡한 보일러 플레이트가 존재해서 러닝커브가 높으며 코드를 알아보기 힘들다.
- 비동기 데이터를 호출하기 위해서 서드파티 라이브러리가 필요하다 Redux-Thunk, Redux-Saga 등
### recoil의 장점
- React 전용 라이브러리여서 React 내부에 접근이 용이하다. 특히 동시성 모드, Suspense 등을 지원해서 UX 관점에서도 유리한 웹 어플리케이션을 만들 수 있다.
- 러닝커브가 낮으며 전역 상태를 정의하고 설정하기가 쉽고 recoil에서 사용하는 훅들로 상태를 get/set하기 때문에 리액트 문법과도 매우 유사하다
- 보일러 플레이트가 매우 적다
### 프로젝트 내 recoil을 사용 예시
- 사용자가 로그인에 성공해서 서버에서 access token을 부여받고 검증된 사용자만 접근할 수 있는 웹페이지에 접속할 경우 token의 validate 여부를 확인해야 하고 게시물이 사용자의 눈에 보일 때 UX적 관점에서 좋아요를 누른 사용자 및 검증된 사용자와 아닌 사용자가 구분이 되어야 하므로 atom에 저장된 token의 payload에 있는 사용자의 정보와 서버에서 받은 데이터를 비교해야 한다
- recoil-persist를 사용하여 웹 스토리지를 atom의 저장소로 사용해서 페이지가 새로고침 될 때 별도의 로직으로 token을 atom의 상태에 넣어주지 않아도 됨

# Why react-query
- 컴포넌트마다 useEffect와 axios를 사용하거나 redux 혹은 contextAPI와 같은 상태 관리 라이브러리를 이용해서 서버의 자원을 받을 때, 만약 하위의 컴포넌트에서 서버의 자원을 변경하면 상위의 컴포넌트는 변경을 감지하기 위해 강제로 페이지를 새로고침 하거나 별도의 복잡한 로직을 짜야한다.
- react-query의 mutate를 사용하면 캐싱된 데이터의 변화 감지를 할 수 있기 때문에 별도의 로직 없이 항상 최신의 서버 상태를 유지할 수 있다.
### 프로젝트 내 react-query 사용한 예시
- 사용자가 좋아요를 누를 때, 서버의 데이터가 변경되어서 UX적 관점에서 하트의 색깔이 다르게 보여야 하지만 서버의 최신상태를 모르기 때문에 좋아요를 누르는 API를 mutate로 사용하여 전체 게시글 불러오는 query instace의 캐싱 데이터를 초기화시켜서 즉시 다른 화면을 볼 수 있게 함

# 인증 방법
### axios interceptor
- axios interceptor를 구현하여 HTTP 요청 시 웹스토리지에 토큰이 있으면 넣어서 서버의 미들웨어(Spring security 등)가 이를 검증하게 함
### PrivateRoutes 컴포넌트 - UX
- props로 가고자하는 URL과 컴포넌트를 넘겨준다.
- 전역 상태(recoil)에 저장되어 있는 토큰을 검증하여 인증되지 않은 사용자가 인증된 사용자만 접근할 수 있는 컴포넌트에 접근할 때, 원래 접근하려고 한 URL을 쿼리 파라미터로 넘겨서 로그인 페이지로 들어가게 한 후, 로그인 페이지에서 로그인 완료시 쿼리 파라미터로 받은 Redirect URL로 돌아게가 한다. UX적 관점에서 생각을 많이 했다.
- 전역 상태에 저장되어 있는 토큰을 검증해서 인증된 사용자라면 원래 가고자한 컴포넌트로 넘어가게 해준다.

# Trouble Shooting
- 서버의 데이터를 변경했을 때, 즉시 화면에 나타나지 않음. ➔ react-query의 mutate로 즉시 최신의 서버 데이터를 화면에 렌더링
- form-data로 사진 파일과 객체를 보낼 때, 서버에서 form-data의 value로 객체 자체를 받을 수 없음 ➔ JSON.stringfy로 보낸 후 서버에서 다시 객체로 파싱
- 페이지가 새로고침 될 때마다 atom의 상태가 날라감 ➔ recoil-persist를 이용해서 atom이 웹 스토리지의 상태를 사용
- state를 사용해서 infinte scroll 구현 시, 좋아요를 눌러도 state엔 좋아요를 누른 데이터를 가진 최신 서버의 데이터가 쌓여있지 않음 ➔ react-query의 useInfiniteQuery를 사용해서 쌓인 데이터를 초기화하고 호출한 페이지만큼 다시 최신 데이터를 

# UX를 많이 고려한 프로젝트
- UX적 요소를 많이 생각하면서 프로젝트를 진행했다. 
- 로그인이 필요한 기능을 사용할 때 로그인 페이지로 넘어간 후 다시 원래 페이지로 돌아오거나 사용자가 focus한 요소가 확대나 강조가 되게하는 기능 및 로그인한 사용자와 로그아웃한 사용자가 다른 메뉴를 보게하는 것과 같은 기능을 많이 생각했다.
- 또한, 미디어 쿼리를 이용하여 반응형으로 웹 디자인을 했다.
- 프론트엔드가 결국 사용자와 직접적으로 소통을 하는 창구임을 잊지 않고 프로젝트를 진행했던 것 같다.


# 그 밖의 고려사항
- eslint & prettier를 사용해서 남과 같이 협업을 할 경우를 고려해 코딩 컨벤션을 맞추었다.
- github action + S3 조합으로 무중단 CI/CD
- CSS 프레임워크가 생각보다 별로라 직접 디자인을 다 했음..

